#一 数据库设计规范

## 1.数据库命名规范
>- 所有数据库对象名称必须使用小写字母并用下划线分割
>>- 因为Linux是严格区分大小写的故Mysql也得大小写敏感
>- 所有数据库对象名称禁止使用mysql保留关键字
>- 数据库对象的命名要能够做到见名识义，并且最好不要超过32个字符
>- 临时表必须以tmp为前缀并以日期为后缀
>- 备份库，别分表必须以bak为前缀并以日期为后缀
>- 所有存储相同数据的列名和列类型必须一致  
## 2.数据库基本设计规范

>- 所有表必须使用Innodb存储引擎(5.6以后默认引擎)
>>- 支持事务，行级锁，更好的恢复性，高并发性能更好
>- 数据库和表的字符集同意使用UTF8
>- 字符集统一可以避免乱码
>- mysql中utf8字符集汉字点3个字节，Ascii占用一个字节
>- 所有表和字段都需要添加注释
>- 使用comment从句添加表和列的备注
>- 从一开始就进行数据字典的维护
>- 尽量控制点数据量的大小，建议控制在500万以内
>- 可以用历史数据归档，分库分表等手段来控制数据大小
>- 谨慎使用musql分区表
>- 分区表在物理上表现为多个文件，在逻辑上表现为一个表
>- 谨慎选择分区键，款分区查询效率可能更低
>- 建议采用物理分表的方式管理大数据
>- 尽量做到冷热数据分离，减少表的宽度
>- 减少磁盘IO，保证热数据的内存缓存命中率
>- 利用更有效的利用缓存，避免读入无用的冷数据
>- 经常一起使用的列放到一个表中
>- 禁止在表中简历预留字段
>- 预留字段的命名很难做到见名识义
>- 预留字段无法确认存储的数据类型，所以无法选择合适的类型
>- 对预留字段类型的修改，对表进行锁定
>- 禁止在数据库中存储图片，文件等二进制数据
>- 禁止在线上做数据库压力测试
>- 禁止从开发环境，测试环境直接连接生产环境的数据库

## 3.数据库索引设计规范

>- 索引对数据库的查询性能来说非常重要的
>- 不要滥用索引
>- 限制每张表上的索引数量，建议单张表索引不超过5个
>- 索引并不是越多越好！索引可以提高效率同样也可以降低效率
>- 禁止给表中的每一列都建立单独的索引
>- 每个Innodb表必须有一个主键
>- 不能使用频繁更新的列作为主键，不使用多列主键
>- 不适用UUID,MD5,HASH，字符串列作为主键
>- 主键建议选择使用自增ID
>- 常见索引列建议
>- select，update，delete语句的where从句中的列包含在order by group by distinct中的字段（最好建立联合索引）
>- 多表join的关联列建立索引
>- 如何选择索引列的顺序
>- 区分度最高的列放在联合索引的最左侧
>- 尽量把字段长度小的类放在联合索引的最左侧
>- 使用最频发的列放到联合索引的左侧
>- 避免建立冗余索引和重复索引
>- 如：primary key(id) index(id) unique index(id)
>- 冗余索引：index(a,b,c) index(a,b)  index(a)
>- 对于频繁的查询优先考虑使用覆盖索引
>- 避免innodb表进行索引的二次查找
>- 可以把随机io变成顺序io加快查询效率
>- 尽量避免使用外键（约束）
>- 外键可用于保证数据的参照完整性，但建议在业务端实现
>- 外键会影响父表和字表的写操作从而降低性能

## 4.数据库字段设计规范
>- 有限选择符合存储需要的最小的数据类型
>>- 将字符床转换为数字类型存储 如：INET_ATON('255.255.255.255')=4294967295   INET_NTOA(4294967295) = '255.255.255.255'
>- 有限选择符合存储需要的最小的数据类型(多一倍空间)
>- 有限选择符合存储需要的最小的数据类型
>>- VARCHAR(N)中的N代表的是字符数，而不是字节数，使用UTF8存储汉字varchar(255)=765字节，过大的长度会消耗更多的内存
>- 避免使用TEXT,BLOB数据类型
>>- 建议把BLOB或者TEXT列分离到单独的扩展表中，TEXT或者BLOB类型只能使用前缀索引
>- 避免使用ENUM数据类型，修改ENUM值需要使用ALTER语句，ENUM类型的ORDER BY操作效率低，需要额外操作，禁止使用数值作为ENUM的枚举值
>- 尽可能把所有列定义为NOT NULL
>>- 索引NULL列需要额外的空间来保存，所以要占用更多的空间进行比较和计算时要对NULL值做特别的处理
>- 不能用字符串存储日期型数据
>>- 缺点1：无法用日期函数进行计算和比较，缺点2：用字符串存储日期要占用更多的空间
>- 使用TIMESTAMP或DATETIME类型存储时间（TIMESTAMP占用4字节和INT相同，但比INT可读性高）超出了用DATETIME
>- 非精准数据类型float，double，同财务相关的金额类数据，必须使用 **decimal** 类型
Decimal类型为精准浮点数，在计算时不会丢失精度，占用空间由定义的宽度决定
可用于存储比bigint更大的整数数据，比varchar更高效


## 5.数据库sql开发规范
>- 建议使用预编译语句进行数据操作（防止注入）
>>- 只传参数，比传递sql语句更高效，相同语句可以一次解析，多次使用，提高处理效率
>- 避免数据类型的隐式转换
>- 充分利用表上已经存在的索引，避免使用双%的查询条件
>>- 一个sql只能利用到复合索引中的一列进行范围查询，使用left join 或者not exists来优化not in操作
>- 程序连接不同的数据库使用不同的账号，禁止跨库查询
>- 禁止使用select*查询，消耗很多的cpu和io以及网络带宽
无法使用覆盖索引，可减少表结构变更带来的影响
>- 禁止使用不含字段列表的insert语句
>- 避免使用子查询，可以把子查询优化为join操作
>>- 子查询的结果集无法使用索引，子查询会产生临时表操作，如果子查询数据量大则严重影响效率，消耗过多的cpu及io资源
>- 便面使用join关联太多的表
>>- 每join一个表多占用一部分内存，会产生临时表坐坐，查询效率，mysql最多关联61个表，建议不要超过5个
>- 减少同数据库的相互次数
>>- 数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率
>- 使用in代替 or
>- 禁止使用order by rand()进行随机排序操作
>- where从句中禁止对列进行函数转换和计算
>- 在明显不会有重复值时使用UNION ALL而不是UNION
>>- UNION会把所有数据放到临时表中后在进行去重操作，union all不会在对数据集进行合并
>- 拆分复杂的大sql为多个小sql

## 6.数据库操作行为规范
>- 超过100万行的批量写操作，要分批多次进行操作
>- 对于大表使用pt-online-schema-change修改表结构
>- 禁止为程序使用的账号赋予super权限
>- 对于程序连接数据库，遵循权限最小原则
>>- 程序使用数据库账号只能在一个DB下使用，不准跨库，程序使用的账号原则上不准有drop权限
